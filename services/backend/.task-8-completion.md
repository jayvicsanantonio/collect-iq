# Task 8: Authenticity Detection Agent - Implementation Summary

## Overview

Successfully implemented the complete authenticity detection agent system for CollectIQ backend. This multi-component system uses perceptual hashing, visual feature analysis, and AI-powered judgment to detect fake Pokémon TCG cards.

## Components Implemented

### 1. Perceptual Hash Utility (`src/utils/phash.ts`)

**Purpose**: Compute visual fingerprints of card images for similarity detection

**Key Features**:

- Implements pHash (Perceptual Hashing) algorithm using DCT (Discrete Cosine Transform)
- Downloads images from S3 and computes 64-bit hash
- Provides Hamming distance calculation for hash comparison
- Converts Hamming distance to similarity scores (0-1 scale)

**Functions**:

- `computePerceptualHash(imageBuffer)` - Core pHash algorithm
- `computePerceptualHashFromS3(s3Key, bucket?)` - Compute hash from S3 image
- `calculateHammingDistance(hash1, hash2)` - Compare two hashes
- `calculateSimilarityScore(hammingDistance)` - Convert distance to similarity

### 2. Reference Hash Comparison (`src/utils/reference-hash-comparison.ts`)

**Purpose**: Compare computed hashes against authentic reference samples

**Key Features**:

- Loads reference hashes from S3 (`authentic-samples/{cardName}/` prefix)
- Compares computed hashes with multiple reference samples
- Returns best match with similarity score
- Graceful degradation when references unavailable

**Functions**:

- `loadReferenceHashes(cardName, bucket?)` - Load reference hashes from S3
- `compareWithReferenceHashes(computedHash, referenceHashes)` - Find best match
- `computeVisualHashConfidence(computedHash, cardName, bucket?)` - Main entry point
- `computeAverageVisualHashConfidence(computedHashes[], cardName, bucket?)` - Batch comparison

### 3. Authenticity Signals Computation (`src/utils/authenticity-signals.ts`)

**Purpose**: Calculate confidence signals from visual features

**Key Features**:

- Text match confidence from OCR validation
- Holographic pattern confidence from variance analysis
- Border consistency from symmetry and ratio metrics
- Font validation from kerning and alignment
- Weighted aggregation into overall score

**Functions**:

- `calculateTextMatchConfidence(ocrBlocks, expectedCardName?)` - OCR validation
- `calculateHoloPatternConfidence(holoVariance, expectedHolo?)` - Holo analysis
- `calculateBorderConsistency(borders)` - Border metrics
- `calculateFontValidation(fontMetrics)` - Font analysis
- `computeAuthenticitySignals(features, visualHashConfidence, ...)` - Aggregate all signals
- `calculateOverallAuthenticityScore(signals)` - Weighted average

**Signal Weights**:

- Visual Hash: 30%
- Text Match: 25%
- Holo Pattern: 20%
- Border Consistency: 15%
- Font Validation: 10%

### 4. Bedrock Service (`src/adapters/bedrock-service.ts`)

**Purpose**: AI-powered authenticity and valuation analysis using AWS Bedrock

**Key Features**:

- Integrates with Claude 3 Sonnet via Bedrock Converse API
- Retry logic with exponential backoff (3 attempts)
- Structured prompts for authenticity and valuation
- JSON response parsing and validation with Zod
- Fallback to signal-based results when AI unavailable

**Methods**:

- `invokeAuthenticity(context)` - AI authenticity judgment
- `invokeValuation(context)` - AI valuation analysis
- Private methods for prompt creation and response parsing

**Configuration** (from environment):

- `BEDROCK_MODEL_ID` - Model to use (default: Claude 3 Sonnet)
- `BEDROCK_MAX_TOKENS` - Max response tokens (default: 2048)
- `BEDROCK_TEMPERATURE` - Temperature setting (default: 0.2)

### 5. Authenticity Agent Lambda Handler (`src/agents/authenticity_agent.ts`)

**Purpose**: Step Functions task that orchestrates authenticity analysis

**Workflow**:

1. Compute perceptual hash from front image
2. Compare with reference hashes for visual confidence
3. Determine if card is expected to be holographic
4. Compute all authenticity signals
5. Invoke Bedrock for AI judgment
6. Return complete AuthenticityResult

**Input Structure**:

```typescript
{
  userId: string;
  cardId: string;
  features: FeatureEnvelope;
  cardMeta: {
    name?: string;
    set?: string;
    rarity?: string;
    frontS3Key: string;
    backS3Key?: string;
  };
  requestId: string;
}
```

**Output Structure**:

```typescript
{
  authenticityResult: {
    authenticityScore: number; // 0-1
    fakeDetected: boolean; // true if score < 0.85
    rationale: string; // AI explanation
    signals: AuthenticitySignals; // Component scores
    verifiedByAI: boolean; // true if Bedrock succeeded
  }
  requestId: string;
}
```

## Integration Points

### S3 Buckets

- **Uploads Bucket**: `BUCKET_UPLOADS` - Card images
- **Reference Samples**: `authentic-samples/{cardName}/{hash}.json` - Authentic reference hashes

### Environment Variables

- `AWS_REGION` - AWS region (default: us-east-1)
- `BUCKET_UPLOADS` - S3 bucket for uploads
- `BEDROCK_MODEL_ID` - Bedrock model ID
- `BEDROCK_MAX_TOKENS` - Max tokens for Bedrock
- `BEDROCK_TEMPERATURE` - Temperature for Bedrock

### Dependencies

- `@aws-sdk/client-s3` - S3 operations
- `@aws-sdk/client-bedrock-runtime` - Bedrock integration
- `sharp` - Image processing for pHash
- `zod` - Response validation
- `@collectiq/shared` - Shared types and schemas

## Authenticity Detection Algorithm

### Phase 1: Visual Hash Analysis

1. Download card image from S3
2. Resize to 32x32 grayscale
3. Compute DCT (Discrete Cosine Transform)
4. Extract low-frequency coefficients
5. Generate 64-bit binary hash
6. Compare with reference hashes using Hamming distance

### Phase 2: Feature Signal Computation

1. **Text Match**: Validate OCR against expected patterns (©, Pokémon, HP, etc.)
2. **Holo Pattern**: Analyze pixel variance in center region
3. **Border Consistency**: Check symmetry and ratio uniformity
4. **Font Validation**: Measure kerning, alignment, size variance

### Phase 3: AI Judgment

1. Package signals and features into context
2. Send to Bedrock with structured prompt
3. Receive AI analysis with score and rationale
4. Set `fakeDetected = true` if score < 0.85

### Fallback Strategy

If Bedrock fails after retries:

- Calculate simple average of signals
- Return with `verifiedByAI = false`
- Include warning in rationale

## Testing Recommendations

### Unit Tests (Not Implemented - Marked Optional)

- pHash computation with known images
- Hamming distance calculations
- Signal computation with mock features
- Bedrock prompt formatting

### Integration Tests (Not Implemented - Marked Optional)

- S3 image download and hash computation
- Reference hash loading from S3
- Bedrock invocation with mock responses
- Complete agent workflow

### Manual Testing

1. Upload authentic card image
2. Trigger authenticity agent
3. Verify high authenticity score (> 0.85)
4. Upload known fake card
5. Verify low score and `fakeDetected = true`

## Performance Considerations

### Optimization Strategies

- Parallel execution in Step Functions (runs alongside pricing agent)
- In-memory caching of reference hashes during Lambda execution
- Efficient DCT computation for pHash
- Retry logic prevents transient failures

### Expected Latency

- pHash computation: ~500ms
- Reference hash comparison: ~200ms
- Signal computation: ~100ms
- Bedrock invocation: ~2-3s
- **Total**: ~3-4s per card

## Security & Privacy

### Data Protection

- No PII logged (only Cognito sub used)
- Structured JSON logging with requestId
- S3 encryption at rest (KMS)
- Secure Bedrock API calls

### Error Handling

- Graceful degradation when references unavailable
- Fallback to signal-based scoring
- Comprehensive error logging
- Step Functions retry on transient failures

## Future Enhancements

1. **Machine Learning Model**: Train custom model on authentic/fake samples
2. **Multi-Angle Analysis**: Compare front and back images
3. **Reference Hash Updates**: Automated collection of authentic samples
4. **Confidence Calibration**: Tune signal weights based on feedback
5. **Real-Time Feedback Loop**: Learn from user corrections

## Requirements Satisfied

✅ **Requirement 6.1**: Visual fingerprinting with perceptual hash and reference comparison
✅ **Requirement 6.2**: Holographic pattern analysis with pixel variance
✅ **Requirement 6.3**: Text validation with OCR and font metrics
✅ **Requirement 6.4**: Bedrock integration for AI judgment
✅ **Requirement 6.5**: Authenticity score (0-1) with rationale
✅ **Requirement 6.6**: Fake detection flag (score < 0.85)
✅ **Requirement 6.7**: Component signals stored for transparency

## Files Created

1. `services/backend/src/utils/phash.ts` (245 lines)
2. `services/backend/src/utils/reference-hash-comparison.ts` (280 lines)
3. `services/backend/src/utils/authenticity-signals.ts` (380 lines)
4. `services/backend/src/adapters/bedrock-service.ts` (520 lines)
5. `services/backend/src/agents/authenticity_agent.ts` (130 lines)

**Total**: ~1,555 lines of production code

## Verification

✅ All TypeScript files compile without errors
✅ All imports and exports properly configured
✅ Zod schemas used for validation
✅ Comprehensive logging throughout
✅ Error handling with fallbacks
✅ Follows existing code patterns and conventions

## Next Steps

The authenticity detection agent is now ready for integration into the Step Functions workflow (Task 10). The agent can be invoked as a Lambda function and will return complete authenticity results including AI-generated rationale.

To use in Step Functions:

```json
{
  "StartAt": "AuthenticityAgent",
  "States": {
    "AuthenticityAgent": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:...:function:authenticity-agent",
      "End": true
    }
  }
}
```
